// Code generated by sqlc. DO NOT EDIT.
// versions:
//   sqlc v1.30.0
// source: balances.sql

package db

import (
	"context"

	"github.com/jackc/pgx/v5/pgtype"
)

const getBalanceByWalletAndUser = `-- name: GetBalanceByWalletAndUser :one
SELECT wallet_id, user_id, net_balance, last_updated_at
FROM balances
WHERE wallet_id = $1 AND user_id = $2
`

type GetBalanceByWalletAndUserParams struct {
	WalletID int32 `json:"wallet_id"`
	UserID   int32 `json:"user_id"`
}

func (q *Queries) GetBalanceByWalletAndUser(ctx context.Context, arg GetBalanceByWalletAndUserParams) (Balance, error) {
	row := q.db.QueryRow(ctx, getBalanceByWalletAndUser, arg.WalletID, arg.UserID)
	var i Balance
	err := row.Scan(
		&i.WalletID,
		&i.UserID,
		&i.NetBalance,
		&i.LastUpdatedAt,
	)
	return i, err
}

const getBalancesByWalletID = `-- name: GetBalancesByWalletID :many
SELECT b.wallet_id, b.user_id, b.net_balance, b.last_updated_at, u.name, u.email
FROM balances b
JOIN users u ON b.user_id = u.id
WHERE b.wallet_id = $1
`

type GetBalancesByWalletIDRow struct {
	WalletID      int32            `json:"wallet_id"`
	UserID        int32            `json:"user_id"`
	NetBalance    pgtype.Numeric   `json:"net_balance"`
	LastUpdatedAt pgtype.Timestamp `json:"last_updated_at"`
	Name          string           `json:"name"`
	Email         string           `json:"email"`
}

func (q *Queries) GetBalancesByWalletID(ctx context.Context, walletID int32) ([]GetBalancesByWalletIDRow, error) {
	rows, err := q.db.Query(ctx, getBalancesByWalletID, walletID)
	if err != nil {
		return nil, err
	}
	defer rows.Close()
	items := []GetBalancesByWalletIDRow{}
	for rows.Next() {
		var i GetBalancesByWalletIDRow
		if err := rows.Scan(
			&i.WalletID,
			&i.UserID,
			&i.NetBalance,
			&i.LastUpdatedAt,
			&i.Name,
			&i.Email,
		); err != nil {
			return nil, err
		}
		items = append(items, i)
	}
	if err := rows.Err(); err != nil {
		return nil, err
	}
	return items, nil
}

const upsertBalance = `-- name: UpsertBalance :one
INSERT INTO balances (wallet_id, user_id, net_balance, last_updated_at)
VALUES ($1, $2, $3, now())
ON CONFLICT (wallet_id, user_id)
DO UPDATE SET net_balance = $3, last_updated_at = now()
RETURNING wallet_id, user_id, net_balance, last_updated_at
`

type UpsertBalanceParams struct {
	WalletID   int32          `json:"wallet_id"`
	UserID     int32          `json:"user_id"`
	NetBalance pgtype.Numeric `json:"net_balance"`
}

func (q *Queries) UpsertBalance(ctx context.Context, arg UpsertBalanceParams) (Balance, error) {
	row := q.db.QueryRow(ctx, upsertBalance, arg.WalletID, arg.UserID, arg.NetBalance)
	var i Balance
	err := row.Scan(
		&i.WalletID,
		&i.UserID,
		&i.NetBalance,
		&i.LastUpdatedAt,
	)
	return i, err
}
