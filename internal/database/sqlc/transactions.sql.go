// Code generated by sqlc. DO NOT EDIT.
// versions:
//   sqlc v1.30.0
// source: transactions.sql

package db

import (
	"context"

	"github.com/jackc/pgx/v5/pgtype"
)

const countTransactionsByUserID = `-- name: CountTransactionsByUserID :one
SELECT COUNT(*) FROM transactions WHERE user_id = $1
`

func (q *Queries) CountTransactionsByUserID(ctx context.Context, userID int32) (int64, error) {
	row := q.db.QueryRow(ctx, countTransactionsByUserID, userID)
	var count int64
	err := row.Scan(&count)
	return count, err
}

const createTransaction = `-- name: CreateTransaction :one
INSERT INTO transactions (
    user_id, plaid_account_id, transaction_id, account_id, amount, date,
    authorized_date, name, merchant_name, pending, payment_channel,
    transaction_code, iso_currency_code, unofficial_currency_code,
    location, payment_meta, personal_finance_category, counterparties
)
VALUES ($1, $2, $3, $4, $5, $6, $7, $8, $9, $10, $11, $12, $13, $14, $15, $16, $17, $18)
ON CONFLICT (transaction_id) DO NOTHING
RETURNING id, user_id, plaid_account_id, transaction_id, account_id, amount, date,
    authorized_date, name, merchant_name, pending, payment_channel,
    transaction_code, iso_currency_code, unofficial_currency_code,
    location, payment_meta, personal_finance_category, counterparties, created_at, updated_at
`

type CreateTransactionParams struct {
	UserID                  int32          `json:"user_id"`
	PlaidAccountID          int32          `json:"plaid_account_id"`
	TransactionID           string         `json:"transaction_id"`
	AccountID               string         `json:"account_id"`
	Amount                  pgtype.Numeric `json:"amount"`
	Date                    pgtype.Date    `json:"date"`
	AuthorizedDate          pgtype.Date    `json:"authorized_date"`
	Name                    string         `json:"name"`
	MerchantName            pgtype.Text    `json:"merchant_name"`
	Pending                 bool           `json:"pending"`
	PaymentChannel          string         `json:"payment_channel"`
	TransactionCode         pgtype.Text    `json:"transaction_code"`
	IsoCurrencyCode         pgtype.Text    `json:"iso_currency_code"`
	UnofficialCurrencyCode  pgtype.Text    `json:"unofficial_currency_code"`
	Location                []byte         `json:"location"`
	PaymentMeta             []byte         `json:"payment_meta"`
	PersonalFinanceCategory []byte         `json:"personal_finance_category"`
	Counterparties          []byte         `json:"counterparties"`
}

func (q *Queries) CreateTransaction(ctx context.Context, arg CreateTransactionParams) (Transaction, error) {
	row := q.db.QueryRow(ctx, createTransaction,
		arg.UserID,
		arg.PlaidAccountID,
		arg.TransactionID,
		arg.AccountID,
		arg.Amount,
		arg.Date,
		arg.AuthorizedDate,
		arg.Name,
		arg.MerchantName,
		arg.Pending,
		arg.PaymentChannel,
		arg.TransactionCode,
		arg.IsoCurrencyCode,
		arg.UnofficialCurrencyCode,
		arg.Location,
		arg.PaymentMeta,
		arg.PersonalFinanceCategory,
		arg.Counterparties,
	)
	var i Transaction
	err := row.Scan(
		&i.ID,
		&i.UserID,
		&i.PlaidAccountID,
		&i.TransactionID,
		&i.AccountID,
		&i.Amount,
		&i.Date,
		&i.AuthorizedDate,
		&i.Name,
		&i.MerchantName,
		&i.Pending,
		&i.PaymentChannel,
		&i.TransactionCode,
		&i.IsoCurrencyCode,
		&i.UnofficialCurrencyCode,
		&i.Location,
		&i.PaymentMeta,
		&i.PersonalFinanceCategory,
		&i.Counterparties,
		&i.CreatedAt,
		&i.UpdatedAt,
	)
	return i, err
}

const getNextUncategorizedTransactionByUserID = `-- name: GetNextUncategorizedTransactionByUserID :one
SELECT t.id, t.user_id, t.plaid_account_id, t.transaction_id, t.account_id, t.amount, t.date,
    t.authorized_date, t.name, t.merchant_name, t.pending, t.payment_channel,
    t.transaction_code, t.iso_currency_code, t.unofficial_currency_code,
    t.location, t.payment_meta, t.personal_finance_category, t.counterparties, t.created_at, t.updated_at
FROM transactions t
LEFT JOIN transaction_categorizations tc ON t.id = tc.transaction_id AND tc.wallet_id = $2
WHERE t.user_id = $1 AND tc.id IS NULL
ORDER BY t.date DESC, t.id DESC
LIMIT 1
`

type GetNextUncategorizedTransactionByUserIDParams struct {
	UserID   int32 `json:"user_id"`
	WalletID int32 `json:"wallet_id"`
}

func (q *Queries) GetNextUncategorizedTransactionByUserID(ctx context.Context, arg GetNextUncategorizedTransactionByUserIDParams) (Transaction, error) {
	row := q.db.QueryRow(ctx, getNextUncategorizedTransactionByUserID, arg.UserID, arg.WalletID)
	var i Transaction
	err := row.Scan(
		&i.ID,
		&i.UserID,
		&i.PlaidAccountID,
		&i.TransactionID,
		&i.AccountID,
		&i.Amount,
		&i.Date,
		&i.AuthorizedDate,
		&i.Name,
		&i.MerchantName,
		&i.Pending,
		&i.PaymentChannel,
		&i.TransactionCode,
		&i.IsoCurrencyCode,
		&i.UnofficialCurrencyCode,
		&i.Location,
		&i.PaymentMeta,
		&i.PersonalFinanceCategory,
		&i.Counterparties,
		&i.CreatedAt,
		&i.UpdatedAt,
	)
	return i, err
}

const getTransactionByID = `-- name: GetTransactionByID :one
SELECT id, user_id, plaid_account_id, transaction_id, account_id, amount, date,
    authorized_date, name, merchant_name, pending, payment_channel,
    transaction_code, iso_currency_code, unofficial_currency_code,
    location, payment_meta, personal_finance_category, counterparties, created_at, updated_at
FROM transactions
WHERE id = $1
`

func (q *Queries) GetTransactionByID(ctx context.Context, id int32) (Transaction, error) {
	row := q.db.QueryRow(ctx, getTransactionByID, id)
	var i Transaction
	err := row.Scan(
		&i.ID,
		&i.UserID,
		&i.PlaidAccountID,
		&i.TransactionID,
		&i.AccountID,
		&i.Amount,
		&i.Date,
		&i.AuthorizedDate,
		&i.Name,
		&i.MerchantName,
		&i.Pending,
		&i.PaymentChannel,
		&i.TransactionCode,
		&i.IsoCurrencyCode,
		&i.UnofficialCurrencyCode,
		&i.Location,
		&i.PaymentMeta,
		&i.PersonalFinanceCategory,
		&i.Counterparties,
		&i.CreatedAt,
		&i.UpdatedAt,
	)
	return i, err
}

const getTransactionByPlaidTransactionID = `-- name: GetTransactionByPlaidTransactionID :one
SELECT id, user_id, plaid_account_id, transaction_id, account_id, amount, date,
    authorized_date, name, merchant_name, pending, payment_channel,
    transaction_code, iso_currency_code, unofficial_currency_code,
    location, payment_meta, personal_finance_category, counterparties, created_at, updated_at
FROM transactions
WHERE transaction_id = $1
`

func (q *Queries) GetTransactionByPlaidTransactionID(ctx context.Context, transactionID string) (Transaction, error) {
	row := q.db.QueryRow(ctx, getTransactionByPlaidTransactionID, transactionID)
	var i Transaction
	err := row.Scan(
		&i.ID,
		&i.UserID,
		&i.PlaidAccountID,
		&i.TransactionID,
		&i.AccountID,
		&i.Amount,
		&i.Date,
		&i.AuthorizedDate,
		&i.Name,
		&i.MerchantName,
		&i.Pending,
		&i.PaymentChannel,
		&i.TransactionCode,
		&i.IsoCurrencyCode,
		&i.UnofficialCurrencyCode,
		&i.Location,
		&i.PaymentMeta,
		&i.PersonalFinanceCategory,
		&i.Counterparties,
		&i.CreatedAt,
		&i.UpdatedAt,
	)
	return i, err
}

const getTransactionsByUserID = `-- name: GetTransactionsByUserID :many
SELECT id, user_id, plaid_account_id, transaction_id, account_id, amount, date,
    authorized_date, name, merchant_name, pending, payment_channel,
    transaction_code, iso_currency_code, unofficial_currency_code,
    location, payment_meta, personal_finance_category, counterparties, created_at, updated_at
FROM transactions
WHERE user_id = $1
ORDER BY date DESC
`

func (q *Queries) GetTransactionsByUserID(ctx context.Context, userID int32) ([]Transaction, error) {
	rows, err := q.db.Query(ctx, getTransactionsByUserID, userID)
	if err != nil {
		return nil, err
	}
	defer rows.Close()
	items := []Transaction{}
	for rows.Next() {
		var i Transaction
		if err := rows.Scan(
			&i.ID,
			&i.UserID,
			&i.PlaidAccountID,
			&i.TransactionID,
			&i.AccountID,
			&i.Amount,
			&i.Date,
			&i.AuthorizedDate,
			&i.Name,
			&i.MerchantName,
			&i.Pending,
			&i.PaymentChannel,
			&i.TransactionCode,
			&i.IsoCurrencyCode,
			&i.UnofficialCurrencyCode,
			&i.Location,
			&i.PaymentMeta,
			&i.PersonalFinanceCategory,
			&i.Counterparties,
			&i.CreatedAt,
			&i.UpdatedAt,
		); err != nil {
			return nil, err
		}
		items = append(items, i)
	}
	if err := rows.Err(); err != nil {
		return nil, err
	}
	return items, nil
}

const getTransactionsByUserIDPaginated = `-- name: GetTransactionsByUserIDPaginated :many
SELECT id, user_id, plaid_account_id, transaction_id, account_id, amount, date,
    authorized_date, name, merchant_name, pending, payment_channel,
    transaction_code, iso_currency_code, unofficial_currency_code,
    location, payment_meta, personal_finance_category, counterparties, created_at, updated_at
FROM transactions
WHERE user_id = $1
ORDER BY date DESC
LIMIT $2 OFFSET $3
`

type GetTransactionsByUserIDPaginatedParams struct {
	UserID int32 `json:"user_id"`
	Limit  int32 `json:"limit"`
	Offset int32 `json:"offset"`
}

func (q *Queries) GetTransactionsByUserIDPaginated(ctx context.Context, arg GetTransactionsByUserIDPaginatedParams) ([]Transaction, error) {
	rows, err := q.db.Query(ctx, getTransactionsByUserIDPaginated, arg.UserID, arg.Limit, arg.Offset)
	if err != nil {
		return nil, err
	}
	defer rows.Close()
	items := []Transaction{}
	for rows.Next() {
		var i Transaction
		if err := rows.Scan(
			&i.ID,
			&i.UserID,
			&i.PlaidAccountID,
			&i.TransactionID,
			&i.AccountID,
			&i.Amount,
			&i.Date,
			&i.AuthorizedDate,
			&i.Name,
			&i.MerchantName,
			&i.Pending,
			&i.PaymentChannel,
			&i.TransactionCode,
			&i.IsoCurrencyCode,
			&i.UnofficialCurrencyCode,
			&i.Location,
			&i.PaymentMeta,
			&i.PersonalFinanceCategory,
			&i.Counterparties,
			&i.CreatedAt,
			&i.UpdatedAt,
		); err != nil {
			return nil, err
		}
		items = append(items, i)
	}
	if err := rows.Err(); err != nil {
		return nil, err
	}
	return items, nil
}

const getUncategorizedTransactionsByUserID = `-- name: GetUncategorizedTransactionsByUserID :many
SELECT t.id, t.user_id, t.plaid_account_id, t.transaction_id, t.account_id, t.amount, t.date,
    t.authorized_date, t.name, t.merchant_name, t.pending, t.payment_channel,
    t.transaction_code, t.iso_currency_code, t.unofficial_currency_code,
    t.location, t.payment_meta, t.personal_finance_category, t.counterparties, t.created_at, t.updated_at
FROM transactions t
LEFT JOIN transaction_categorizations tc ON t.id = tc.transaction_id AND tc.wallet_id = $2
WHERE t.user_id = $1 AND tc.id IS NULL
ORDER BY t.date DESC
`

type GetUncategorizedTransactionsByUserIDParams struct {
	UserID   int32 `json:"user_id"`
	WalletID int32 `json:"wallet_id"`
}

func (q *Queries) GetUncategorizedTransactionsByUserID(ctx context.Context, arg GetUncategorizedTransactionsByUserIDParams) ([]Transaction, error) {
	rows, err := q.db.Query(ctx, getUncategorizedTransactionsByUserID, arg.UserID, arg.WalletID)
	if err != nil {
		return nil, err
	}
	defer rows.Close()
	items := []Transaction{}
	for rows.Next() {
		var i Transaction
		if err := rows.Scan(
			&i.ID,
			&i.UserID,
			&i.PlaidAccountID,
			&i.TransactionID,
			&i.AccountID,
			&i.Amount,
			&i.Date,
			&i.AuthorizedDate,
			&i.Name,
			&i.MerchantName,
			&i.Pending,
			&i.PaymentChannel,
			&i.TransactionCode,
			&i.IsoCurrencyCode,
			&i.UnofficialCurrencyCode,
			&i.Location,
			&i.PaymentMeta,
			&i.PersonalFinanceCategory,
			&i.Counterparties,
			&i.CreatedAt,
			&i.UpdatedAt,
		); err != nil {
			return nil, err
		}
		items = append(items, i)
	}
	if err := rows.Err(); err != nil {
		return nil, err
	}
	return items, nil
}

const updateTransactionPendingStatus = `-- name: UpdateTransactionPendingStatus :exec
UPDATE transactions
SET pending = $2, updated_at = now()
WHERE transaction_id = $1
`

type UpdateTransactionPendingStatusParams struct {
	TransactionID string `json:"transaction_id"`
	Pending       bool   `json:"pending"`
}

func (q *Queries) UpdateTransactionPendingStatus(ctx context.Context, arg UpdateTransactionPendingStatusParams) error {
	_, err := q.db.Exec(ctx, updateTransactionPendingStatus, arg.TransactionID, arg.Pending)
	return err
}
