// Code generated by sqlc. DO NOT EDIT.
// versions:
//   sqlc v1.30.0
// source: transaction_categorizations.sql

package db

import (
	"context"

	"github.com/jackc/pgx/v5/pgtype"
)

const createTransactionCategorization = `-- name: CreateTransactionCategorization :one
INSERT INTO transaction_categorizations (transaction_id, wallet_id, category_type, categorized_by_user_id)
VALUES ($1, $2, $3, $4)
RETURNING id, transaction_id, wallet_id, category_type, categorized_by_user_id, categorized_at
`

type CreateTransactionCategorizationParams struct {
	TransactionID       int32  `json:"transaction_id"`
	WalletID            int32  `json:"wallet_id"`
	CategoryType        string `json:"category_type"`
	CategorizedByUserID int32  `json:"categorized_by_user_id"`
}

func (q *Queries) CreateTransactionCategorization(ctx context.Context, arg CreateTransactionCategorizationParams) (TransactionCategorization, error) {
	row := q.db.QueryRow(ctx, createTransactionCategorization,
		arg.TransactionID,
		arg.WalletID,
		arg.CategoryType,
		arg.CategorizedByUserID,
	)
	var i TransactionCategorization
	err := row.Scan(
		&i.ID,
		&i.TransactionID,
		&i.WalletID,
		&i.CategoryType,
		&i.CategorizedByUserID,
		&i.CategorizedAt,
	)
	return i, err
}

const deleteTransactionCategorization = `-- name: DeleteTransactionCategorization :exec
DELETE FROM transaction_categorizations
WHERE transaction_id = $1 AND wallet_id = $2
`

type DeleteTransactionCategorizationParams struct {
	TransactionID int32 `json:"transaction_id"`
	WalletID      int32 `json:"wallet_id"`
}

func (q *Queries) DeleteTransactionCategorization(ctx context.Context, arg DeleteTransactionCategorizationParams) error {
	_, err := q.db.Exec(ctx, deleteTransactionCategorization, arg.TransactionID, arg.WalletID)
	return err
}

const getCategorizationByTransactionAndWallet = `-- name: GetCategorizationByTransactionAndWallet :one
SELECT id, transaction_id, wallet_id, category_type, categorized_by_user_id, categorized_at
FROM transaction_categorizations
WHERE transaction_id = $1 AND wallet_id = $2
`

type GetCategorizationByTransactionAndWalletParams struct {
	TransactionID int32 `json:"transaction_id"`
	WalletID      int32 `json:"wallet_id"`
}

func (q *Queries) GetCategorizationByTransactionAndWallet(ctx context.Context, arg GetCategorizationByTransactionAndWalletParams) (TransactionCategorization, error) {
	row := q.db.QueryRow(ctx, getCategorizationByTransactionAndWallet, arg.TransactionID, arg.WalletID)
	var i TransactionCategorization
	err := row.Scan(
		&i.ID,
		&i.TransactionID,
		&i.WalletID,
		&i.CategoryType,
		&i.CategorizedByUserID,
		&i.CategorizedAt,
	)
	return i, err
}

const getSharedTransactionsByWalletID = `-- name: GetSharedTransactionsByWalletID :many
SELECT t.id, t.user_id, t.plaid_account_id, t.transaction_id, t.account_id, t.amount, t.date,
    t.authorized_date, t.name, t.merchant_name, t.pending, t.payment_channel,
    t.transaction_code, t.iso_currency_code, t.unofficial_currency_code,
    t.location, t.payment_meta, t.personal_finance_category, t.counterparties, t.created_at, t.updated_at,
    tc.category_type, tc.categorized_by_user_id, tc.categorized_at
FROM transactions t
JOIN transaction_categorizations tc ON t.id = tc.transaction_id
WHERE tc.wallet_id = $1 AND tc.category_type = 'shared'
ORDER BY t.date DESC
`

type GetSharedTransactionsByWalletIDRow struct {
	ID                      int32            `json:"id"`
	UserID                  int32            `json:"user_id"`
	PlaidAccountID          int32            `json:"plaid_account_id"`
	TransactionID           string           `json:"transaction_id"`
	AccountID               string           `json:"account_id"`
	Amount                  pgtype.Numeric   `json:"amount"`
	Date                    pgtype.Date      `json:"date"`
	AuthorizedDate          pgtype.Date      `json:"authorized_date"`
	Name                    string           `json:"name"`
	MerchantName            pgtype.Text      `json:"merchant_name"`
	Pending                 bool             `json:"pending"`
	PaymentChannel          string           `json:"payment_channel"`
	TransactionCode         pgtype.Text      `json:"transaction_code"`
	IsoCurrencyCode         pgtype.Text      `json:"iso_currency_code"`
	UnofficialCurrencyCode  pgtype.Text      `json:"unofficial_currency_code"`
	Location                []byte           `json:"location"`
	PaymentMeta             []byte           `json:"payment_meta"`
	PersonalFinanceCategory []byte           `json:"personal_finance_category"`
	Counterparties          []byte           `json:"counterparties"`
	CreatedAt               pgtype.Timestamp `json:"created_at"`
	UpdatedAt               pgtype.Timestamp `json:"updated_at"`
	CategoryType            string           `json:"category_type"`
	CategorizedByUserID     int32            `json:"categorized_by_user_id"`
	CategorizedAt           pgtype.Timestamp `json:"categorized_at"`
}

func (q *Queries) GetSharedTransactionsByWalletID(ctx context.Context, walletID int32) ([]GetSharedTransactionsByWalletIDRow, error) {
	rows, err := q.db.Query(ctx, getSharedTransactionsByWalletID, walletID)
	if err != nil {
		return nil, err
	}
	defer rows.Close()
	items := []GetSharedTransactionsByWalletIDRow{}
	for rows.Next() {
		var i GetSharedTransactionsByWalletIDRow
		if err := rows.Scan(
			&i.ID,
			&i.UserID,
			&i.PlaidAccountID,
			&i.TransactionID,
			&i.AccountID,
			&i.Amount,
			&i.Date,
			&i.AuthorizedDate,
			&i.Name,
			&i.MerchantName,
			&i.Pending,
			&i.PaymentChannel,
			&i.TransactionCode,
			&i.IsoCurrencyCode,
			&i.UnofficialCurrencyCode,
			&i.Location,
			&i.PaymentMeta,
			&i.PersonalFinanceCategory,
			&i.Counterparties,
			&i.CreatedAt,
			&i.UpdatedAt,
			&i.CategoryType,
			&i.CategorizedByUserID,
			&i.CategorizedAt,
		); err != nil {
			return nil, err
		}
		items = append(items, i)
	}
	if err := rows.Err(); err != nil {
		return nil, err
	}
	return items, nil
}
